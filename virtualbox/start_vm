#!/bin/bash
# vim: ts=4:sw=4

[ ! -t 0 ] && PLELIB_OUTPUT=DISABLE || true
. ~/plescripts/plelib.sh
. ~/plescripts/virtualbox/vboxlib.sh
. ~/plescripts/usagelib.sh
. ~/plescripts/global.cfg
EXEC_CMD_ACTION=EXEC

typeset -r ME=$0
typeset -r PARAMS="$*"

typeset		server=undef
typeset		wait_os=yes
typeset		dataguard=yes
typeset		lsvms=yes

add_usage "[-server=name]"			"Si non définie testera ID_DB (cf set_db)"
add_usage "[-dataguard=$dataguard]"	"yes|no, yes : démarre toutes les VMs du dataguard."
add_usage "[-wait_os=$wait_os]"		"yes|no, yes : attend le démarrage complet de l'OS avant de poursuivre."
add_usage "[-lsvms=$lsvms]"			"yes|no"

typeset -r str_usage=\
"Usage : $ME
$(print_usage)
"

while [ $# -ne 0 ]
do
	case $1 in
		-emul)
			EXEC_CMD_ACTION=NOP
			first_args=-emul
			shift
			;;

		-server=*)
			server=${1##*=}
			shift
			;;

		-lsvms=*)
			lsvms=$(to_lower ${1##*=})
			shift
			;;

		-wait_os=*)
			wait_os=${1##*=}
			shift
			;;

		-dataguard=*)
			dataguard=${1##*=}
			shift
			;;

		-h|-help|help)
			info "$str_usage"
			LN
			exit 1
			;;

		*)
			if [ $server == undef ]
			then
				server=$1
				shift
			else
				error "Arg '$1' invalid."
				LN
				info "$str_usage"
				exit 1
			fi
			;;
	esac
done

[[ $server == undef && -v ID_DB ]] && server=$ID_DB || true
exit_if_param_undef server	"$str_usage"

exit_if_param_invalid wait_os "yes no" "$str_usage"

#	$1 vm name
#	print group name to stdout
function group_name_for_vm
{
	VBoxManage showvminfo "$1" | grep -E "^Groups:" | cut -d/ -f2-
}

#	$1 group name
#	$2 vm name to exclude
#	register all VMs in group $1 to dataguard_list
#	Declare dataguard_list before to call function : typeset -a dataguard_list
function load_vm_in_group
{
	typeset -r search_group="$1"
	typeset	-r exclude="$2"

	while read vm_name
	do
		[[ x"$vm_name" == x || "$vm_name" == "$exclude" ]] && continue || true

		if [ "$(group_name_for_vm $vm_name)" == "$search_group" ]
		then
			dataguard_list+=( $vm_name ) 
		fi
	done<<<"$(VBoxManage list vms | cut -d\" -f2)"
}

#	Load to vm_list all server who match $server
#	exit 1 if no server found.
function load_vm_list
{
	while read vm_name
	do
		[ x"$vm_name" != x ] && vm_list+=( $vm_name )
	done<<<"$(VBoxManage list vms | grep "$server" | cut -d\" -f2)"

	info "${#vm_list[@]} server(s) found for pattern $server : ${vm_list[*]}"
	LN

	[ ${#vm_list[@]} -eq 0 ] && exit 1 || true
}

typeset -a vm_list			# Nom de toutes les VMs.
typeset -i nr_vm_started=0	# Nombre de VM démarré.
typeset	-a vm_started_list	# Nom des VMs démarrées.
typeset	-a dataguard_list	# Nom des autres VMs dans le groupe dataguard.

if [ $server != $infra_hostname ] && ! vm_running $infra_hostname
then
	warning "$infra_hostname not running."
	exec_cmd "start_vm $infra_hostname"
	info "continue..."
	LN
fi

#	============================================================================
load_vm_list

#	============================================================================
#	Démarre les VMs :
for vm in ${vm_list[*]}
do

	if vm_running $vm
	then
		info "$vm is running."
		LN
		continue
	fi

	exec_cmd -c "VBoxManage startvm $vm --type headless"
	if [ $? -eq 0 ]
	then
		sleep 2	# RAC 12.2 le premier nœud par tjrs en live.
		((++nr_vm_started))
		vm_started_list+=( $vm )
		if [[ $dataguard == yes && ${#vm_list[@]} -eq 1 ]]
		then # Actuellement seul les serveurs standalone sont en DG.
			dg_group="$(group_name_for_vm $vm)"
			if [ "${dg_group:0:2}" == "DG" ]
			then
				load_vm_in_group "$dg_group" "$vm"
			fi
		fi
	else
		error "Failed to start $vm" 
	fi
	LN

done

#	============================================================================
#	Démarre les éventuelles autres VMs du dataguard.
if [ ${#dataguard_list[@]} -ne 0 ]
then
	line_separator
	info "Start dataguard members : ${dataguard_list[*]}"
	for vm_name in ${dataguard_list[*]}
	do
		if vm_running $vm_name
		then
			info "$vm_name is running."
		else
			vm_list+=( $vm_name )
			exec_cmd -c "VBoxManage startvm $vm_name --type headless"
			if [ $? -eq 0 ]
			then
				sleep 2
				vm_started_list+=( $vm_name )
				((++nr_vm_started))
			fi
		fi
		LN
	done
fi

#	============================================================================
if [[ $EXEC_CMD_ACTION == EXEC && $wait_os == yes ]]
then
	line_separator
	for vm in ${vm_started_list[*]}
	do
		exec_cmd wait_server $vm
		LN
	done
fi

#	============================================================================
if [[ $PLELIB_OUTPUT != DISABLE && $lsvms == yes ]]
then
	line_separator
	exec_cmd "lsvms"
fi

#	============================================================================
if [ $nr_vm_started -eq ${#vm_list[@]} ]
then
	exit 0	# Toutes les VMs ont démarrés.
else
	exit 1	# Au moins une VM n'a pas démarré.
fi
