#!/bin/bash
# vim: ts=4:sw=4

. ~/plescripts/plelib.sh
. ~/plescripts/usagelib.sh
. ~/plescripts/global.cfg
EXEC_CMD_ACTION=EXEC

typeset -r ME=$0

script_banner $ME $@

typeset server=undef
typeset	wait_os=yes
typeset reboot_vbox=no
typeset error_on_poweroff=no
typeset	dataguard=yes

add_usage "[-server=name]"			"Si non définie testera ID_DB (cf set_db)"
add_usage "[-dataguard=$dataguard]"	"yes|no, yes : arrête toutes les VMs du dataguard."
add_usage "[-wait_os=$wait_os]"		"yes|no, yes : attend l'arrêt complet de l'OS avant de poursuivre."
add_usage "[-reboot_vbox]"			"Reboot tous les composants de vbox."
add_usage "[-error_on_poweroff]"	"Si un poweroff est nécessaire retourne 1"

typeset -r str_usage=\
"Usage : $ME
$(print_usage)
"

while [ $# -ne 0 ]
do
	case $1 in
		-emul)
			EXEC_CMD_ACTION=NOP
			shift
			;;

		-server=*)
			server=${1##*=}
			shift
			;;

		-wait_os=*)
			wait_os=${1##*=}
			shift
			;;

		-reboot_vbox)
			reboot_vbox=yes
			shift
			;;

		-error_on_poweroff)
			error_on_poweroff=yes
			shift
			;;

		-dataguard=*)
			dataguard=${1##*=}
			shift
			;;

		-h|-help|help)
			info "$str_usage"
			LN
			exit 1
			;;

		*)
			if [ $server == undef ]
			then
				server=$1
				shift
			else
				error "Arg '$1' invalid."
				LN
				info "$str_usage"
				exit 1
			fi
			;;
	esac
done

[[ $server == undef && -v ID_DB ]] && server=$ID_DB || true
exit_if_param_undef server	"$str_usage"

# $1 vm name
function wait_vm_until_stopped
{
	typeset -r	vm_name="$1"

	typeset	-ri	wait_max_secs=120
	typeset	-i	secs=0

	typeset		display_color

	hide_cursor
	info -n "Server $vm_name stopping "
	while [ 0 -eq 0 ]
	do
		if ! VBoxManage list runningvms | grep -q $vm_name
		then
			LN
			break
		fi
		info -f -n "${display_color}.${NORM}"
		if [ $secs -eq $wait_max_secs ]
		then
			LN
			warning "$vm_name not stopped after ${secs}s"
			exec_cmd -c "VBoxManage controlvm $vm_name poweroff"
			break
		elif [[ $secs -ne 0 && $(( secs % 10 )) -eq 0 ]]
		then
			info -f -n "${display_color}${secs}s${NORM}"
			if [[ $secs -ge 30 && $secs -lt 60 ]]
			then
				display_color=$PINK
			elif [[ $secs -ge 60 && $sec -lt 90 ]]
			then
				display_color=$YELLOW
			elif [[ $sec -ge 90 ]]
			then
				display_color=$RED
			fi
		fi
		sleep 1
		((++secs))
	done
	show_cursor
}

#	$1 vm name
#	print group name to stdout
function group_name_for_vm
{
	VBoxManage showvminfo "$1" | grep -E "^Groups:" | cut -d/ -f2-
}

#	$1 group name
#	$2 vm name to exclude
#	register all VMs in group $1 to dataguard_list
#	Declare dataguard_list before to call function : typeset -a dataguard_list
function load_vm_in_group
{
	typeset -r search_group="$1"
	typeset	-r exclude="$2"

	while read vm_name
	do
		[[ x"$vm_name" == x || "$vm_name" == "$exclude" ]] && continue || true

		if [ "$(group_name_for_vm $vm_name)" == "$search_group" ]
		then
			dataguard_list+=( $vm_name )
		fi
	done<<<"$(VBoxManage list vms | cut -d\" -f2)"
}

# $1 vm name
# return 0 if running, else 1
function vm_running
{
	grep -q "$1"<<<"$(VBoxManage list runningvms)"
}

#	$1 vm name
function stop_vm_name
{
	typeset -r vm_to_stop="$1"

	exec_cmd -c "VBoxManage controlvm $vm_to_stop acpipowerbutton"
	if [ $? -ne 0 ]
	then
		error "Failed to stop $vm_to_stop"
		LN

		if [ $error_on_poweroff == yes ]
		then
			((++count_errors))
		else
			line_separator
			info "Poweroff : $vm_to_stop"
			exec_cmd -c "VBoxManage controlvm $vm_to_stop poweroff"
			if [ $? -ne 0 ]
			then
				error "Failed to poweroff $vm_to_stop"
				((++count_errors))
			else
				vm_stopped_list+=( $vm_to_stop )
			fi
		fi
	else
		vm_stopped_list+=( $vm_to_stop )
	fi
}

typeset -a vm_list			# Nom de toutes les VMs running
typeset -a vm_stopped_list	# Nom des VMs stoppées.
typeset	-a dataguard_list	# Nom des autres VMs dans le groupe dataguard.
typeset -i count_errors=0

# Si arrêt de la VM d'infra alors tous les serveurs de base de données sont
# stoppés. Le nom des serveurs de base de données commence par srv.
[ "$server" == "$infra_hostname" ] && server="srv" || true

#===============================================================================
# Mémorise dans vm_list le nom des VMs runnings correspondantes au pattern $server
while read vm_name
do
	[ x"$vm_name" != x ] && vm_list+=( $vm_name )
done<<<"$(VBoxManage list runningvms | grep "$server" | cut -d\" -f2)"

[ "$server" == srv ] && info "Stop infra server : $infra_hostname" || true
info "${#vm_list[@]} running VMs found for pattern $server : ${vm_list[@]}"
LN

if [ ${#vm_list[@]} -eq 0 ]
then
	[ "$server" != srv ] && exit 0 || true
else
	#===========================================================================
	# Stop les VMs et mémorise leurs noms dans vm_stopped_list
	# Mémorise le nom des serveurs en dataguard dans dataguard_list.
	line_separator
	for vm in ${vm_list[@]}
	do
		stop_vm_name "$vm"

		if [[ $dataguard == yes && ${#vm_list[@]} -eq 1 ]]
		then # Actuellement seul les serveurs standalone sont en DG.
			dg_group="$(group_name_for_vm $vm)"
			if [ "${dg_group:0:2}" == "DG" ]
			then
				load_vm_in_group "$dg_group" "$vm"
			fi
		fi

		LN
	done

	if [ ${#dataguard_list[@]} -ne 0 ]
	then
		#	====================================================================
		#	Arrête les éventuelles autres VMs du dataguard.
		line_separator
		info "Stop dataguard members : ${dataguard_list[*]}"
		for vm_name in ${dataguard_list[*]}
		do
			if vm_running $vm_name
			then
				vm_list+=( $vm_name )
				stop_vm_name "$vm_name"
				LN
			else
				info "$vm_name not running."
				LN
			fi
		done
	fi

	#===========================================================================
	if [[ $EXEC_CMD_ACTION == EXEC && $wait_os == yes ]]
	then	# Attend que toutes les VMs soient stoppée.
		typeset -ri	stop_at=$SECONDS
		line_separator
		typeset -i count=0
		for vm_2_wait in ${vm_stopped_list[*]}
		do
			wait_vm_until_stopped "$vm_2_wait"
			[ $count -ne 0 ] && LN || true
			((++count))
		done
		typeset -ri	duration=$(( SECONDS - stop_at ))
		info "Total waiting : $(fmt_seconds $duration)"
		timing 2
	fi
fi

if [ "$server" == srv ]
then # Arrêt de la VM d'infra quand tous les serveurs sont stoppés.
	stop_vm_name $infra_hostname
	wait_vm_until_stopped $infra_hostname
	timing 2
fi

#===============================================================================
if [ $count_errors -ne 0 ]
then
	warning "$count_errors failed."
	exit 1
else
	if [[ $reboot_vbox == yes && $(VBoxManage list runningvms | wc -l) -eq 1 ]]
	then # Ne fonctionnera qu'avec l'option -wait_os
		exec_cmd "~/plescripts/virtualbox/restart_vboxdrv.sh"
	fi
	exit 0
fi
