set ts=4
set sw=4
set listchars=tab:→\ ,eol:¬,trail:⋅,nbsp:⋅
set cc=81 wrap
set nu
set vb t_vb=
set noerrorbells

if !has("compatible")
"	A partir d'ici la configuration n'est pas compatible avec vi.

if !exists( "g:first_load" )
	" Permet d'éviter certaines actions sur
	" un rechargement du fichier
	let g:first_load=1
else
	let g:first_load=0
endif

"	Pathogen
let g:pathogen_disabled = []
if has("gui_running")
	call add(g:pathogen_disabled, 'vim-togglemouse')
endif

call pathogen#infect()
call pathogen#helptags()

" Restore screen size and position
" Saves data in a separate file, and so works with multiple instances of Vim.
if has("gui_running")
  function! ScreenFilename()
    if has('amiga')
      return "s:.vimsize"
    elseif has('win32')
      return $HOME.'\_vimsize'
    else
      return $HOME.'/.vimsize'
    endif
  endfunction

  function! ScreenRestore()
    " - Remembers and restores winposition, columns and lines stored in
    "   a .vimsize file
    " - Must follow font settings so that columns and lines are accurate
    "   based on font size.
    if !has("gui_running")
      return
    endif
    if g:screen_size_restore_pos != 1
      return
    endif
    let vim_instance = (g:screen_size_by_vim_instance==1?(v:servername):'GVIM')
    " read any existing variables from .vimsize file
    silent! execute "sview " . escape(ScreenFilename(),'%#\ $')
    silent! execute "0/^" . vim_instance . " /"
    let vim_name  = matchstr(getline('.'), '^\w\+')
    let vim_cols  = matchstr(getline('.'), '^\w\+\s\+\zs\d\+')
    let vim_lines = matchstr(getline('.'), '^\w\+\s\+\d\+\s\+\zs\d\+')
    let vim_posx  = matchstr(getline('.'), '^\w\+\s\+\d\+\s\+\d\+\s\+\zs\d\+')
    let vim_posy  = matchstr(getline('.'), '^\w\+\s\+\d\+\s\+\d\+\s\+\d\+\s\+\zs\d\+')
    if vim_name == vim_instance
      execute "set columns=".vim_cols
      execute "set lines=".vim_lines
      silent! execute "winpos ".vim_posx." ".vim_posy
    endif
    silent! q
  endfunction

  function! ScreenSave()
    " used on exit to retain window position and size
    if !has("gui_running")
      return
    endif
    if !g:screen_size_restore_pos
      return
    endif
    let vim_instance = (g:screen_size_by_vim_instance==1?(v:servername):'GVIM')
    silent! execute "split " . escape(ScreenFilename(),'%#\ $')
    silent! execute "0/^" . vim_instance . " /"
    let vim_name  = matchstr(getline('.'), '^\w\+')
    if vim_name == vim_instance
      delete _
    endif
    $put = vim_instance . ' ' . &columns . ' ' . &lines . ' ' .
          \ (getwinposx()<0?0:getwinposx()) . ' ' .
          \ (getwinposy()<0?0:getwinposy())
    silent! x!
  endfunction

  if !exists('g:screen_size_restore_pos')
    let g:screen_size_restore_pos = 1
  endif
  if !exists('g:screen_size_by_vim_instance')
    let g:screen_size_by_vim_instance = 1
  endif
  autocmd VimEnter * call ScreenRestore()
  autocmd VimLeavePre * call ScreenSave()
endif

" Pour mes fichiers template je désactive la syntaxe
autocmd BufNewFile,BufRead *.template set syn=off

"	Activé pour le plugin markdown
filetype plugin on

if has("gui_running")
	let g:light_colors_name = 'github'
	let g:dark_colors_name = 'sourcerer'
	let g:colors_name=g:light_colors_name	" Théme par défaut
	set guifont=Monospace\ 12
	set guioptions+=b
	set cc=81 nonu nowrap
else
	silent! set mouse=a
	let g:light_colors_name = 'github'
	let g:dark_colors_name = 'sourcerer'
	"	Théme par défaut
	if $HOSTNAME == 'K2'
		let g:colors_name=g:dark_colors_name
	else
		let g:colors_name=g:light_colors_name
	endif

	set cc=81 nu wrap linebreak
endif

"	Recharge automatiquement les fichiers modifiés.
set autoread

"   Ne charge pas le driver noshowmatch qui est trop lent.
let loaded_matchparen = 1

"Pour que airline soit visible tout le temps
set laststatus=2

"Search
set hlsearch
set incsearch

" Don't redraw while executing macros (good performance config)
set lazyredraw

" For regular expressions turn magic on
set magic

"	============================================================================
"	Syntastic : configuration conseillé
"	============================================================================
set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*
" Ne fonctionne pas avec Airline :(
set statusline+=%{&spelllang}

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0

"	============================================================================
"	Dictionnaire :
"	============================================================================
"let g:languagetool_jar='/home/kangs/.vim/LanguageTool-3.4/languagetool-commandline.jar'
"let g:languagetool_disable_rules="FRENCH_WHITESPACE,WHITESPACE_RULE,FIXTURE,EMAIL,HUNSPELL_NO_SUGGEST_RULE"
let g:grammarous#disabled_rules = {
	\ '*' : ['FRENCH_WHITESPACE,WHITESPACE_RULE,FIXTURE,EMAIL,HUNSPELL_NO_SUGGEST_RULE'],
	\ 'help' : ['WHITESPACE_RULE', 'EN_QUOTES', 'SENTENCE_WHITESPACE', 'UPPERCASE_SENTENCE_START'],
	\ }
function! FrGrammaire()
	if (! exists ("b:grammar_is"))
		let b:grammar_is = 'no'
	endif

	if b:grammar_is == 'us'
		let b:grammar_is='no'
		:LanguageToolClear
	endif

	if b:grammar_is == 'no'
		:echo "Grammaire française activée."
		let b:grammar_is='fr'
		if ( &filetype == 'sh' )
			:GrammarousCheck --lang=fr --comments-only
		else
			:GrammarousCheck --lang=fr --no-comments-only
		endif
	elseif b:grammar_is == 'fr'
		:echo "Grammaire française désactivée."
		let b:grammar_is='no'
		:GrammarousReset
	endif
endfunction

function! FrDictionnaire()
	if (! exists ("b:dictionnary_is"))
		let b:dictionnary_is = 'no'
	endif

	if b:dictionnary_is == 'us'
		let b:dictionnary_is='no'
		:setlocal nospell
	endif

	if b:dictionnary_is == 'no'
		:echo "Dictionnaire français."
		let b:dictionnary_is='fr'
		:setlocal spell spelllang=fr
	elseif b:dictionnary_is == 'fr'
		:echo "Dictionnaire désactivé."
		let b:dictionnary_is='no'
		:setlocal nospell
	endif
endfunction

function! UsGrammaire()
	if (! exists ("b:grammar_is"))
		let b:grammar_is = 'no'
	endif

	if b:grammar_is == 'fr'
		let b:grammar_is='no'
		:setlocal nospell
		if exists( "g:languagetool_jar" )
			:LanguageToolClear
		endif
	endif

	if b:grammar_is == 'no'
		:echo "Dictionnaire US."
		let b:grammar_is='us'
		:setlocal spell spelllang=en_us
		if exists( "g:languagetool_jar" )
			:LanguageToolCheck
		endif
	elseif b:grammar_is == 'us'
		:echo "Dictionnaire désactivé."
		let b:grammar_is='no'
		:setlocal nospell
		if exists( "g:languagetool_jar" )
			:LanguageToolClear
		endif
	endif
endfunction

nnoremap <F2> :call FrDictionnaire()<CR>
"if exists( "g:languagetool_jar" )
	nnoremap <C-g> :call FrGrammaire()<CR>
"endif

"	============================================================================
"	Foldmethod
"	============================================================================
set foldlevel=0
set foldnestmax=1

"	Permet de (un)folder la fonction courante avec la touche space.
nnoremap <silent> <Space> @=(foldlevel('.')?'za':"\<Space>")<CR>
vnoremap <Space> zf

function! ToggleAllFolders()
	if (! exists ("b:toggle_all_folders_state"))
		let b:toggle_all_folders_state = 'folded'
	endif

	if b:toggle_all_folders_state == 'folded'
		:echo "Functions unfolded"
		let b:toggle_all_folders_state='unfolded'
		normal! zR
	else
		:echo "Functions folded"
		let b:toggle_all_folders_state='folded'
		normal! zM
	endif
endfunction
map <F3> :call ToggleAllFolders()<CR>

function! CallbackShellFoldBrace()
	if getline(v:lnum+1)[0] == '{'
		return '>1'
	endif

	if getline(v:lnum)[0] == '}'
		return '<1'
	endif

	return -1
endfunction
set foldexpr=CallbackShellFoldBrace()

function! EnableShellFoldBrace()
	if &filetype == '' && getline(1) == '#!.*sh'
		set filetype=sh
	endif

	if &filetype == 'sh'
		set foldmethod=expr
	else
		set foldmethod=manual
		if exists ("g:toggle_all_folders_state") && g:toggle_all_folders_state == 'folded'
			call ToggleAllFolders()
		endif
	endif
endfunction
autocmd BufNewFile,BufRead * call EnableShellFoldBrace()

"	============================================================================
"	Répertoires :
"	Bascule entre $HOME et $HOME/plescripts
"	============================================================================
"	NERDTreeChDirMode
function! ToggleHOME2Plescripts ()
	let l:new_dir=$HOME
	if getcwd() == $HOME
		let l:new_dir='$HOME/plescripts'
	endif
	execute "cd ".l:new_dir
	execute "NERDTree ".l:new_dir
	wincmd p	"Go to previous windows
endfunction
map <silent> <F4> :call ToggleHOME2Plescripts()<CR>

"	NERDTreeChDirMode
function! ToggleHOME2Plewiki ()
	let l:new_dir=$HOME
	if getcwd() == $HOME
		let l:new_dir='$HOME/plewiki'
	endif
	execute "cd ".l:new_dir
	execute "NERDTree ".l:new_dir
	wincmd p	"Go to previous windows
endfunction
"map <silent> <C-F4> :call ToggleHOME2Plewiki()<CR>


"	============================================================================
"	NERDTree
"	============================================================================
let NERDTreeIgnore=['\.swp$', '\~$']

if has( "gui_running" )
	" NERDTree ouvert automatiquement
	autocmd VimEnter * NERDTree %:p:h
else
	" NERDTree ouvert si aucun fichier n'est passé en paramètre.
	autocmd StdinReadPre * let s:std_in=1
	autocmd VimEnter * if argc() == 0 && !exists("s:std_in") | NERDTree %:p:h | endif
endif
map <silent> <F5> :NERDTreeToggle<CR>

"Si NERDTree est la dernière fenêtre ouverte alors quitter [G]vim
autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif

" Go to previous (last accessed) window.
autocmd VimEnter * wincmd p

"	============================================================================
"	Thème :
"	============================================================================
function! SpellSettings()
	" Améliore considérablement la lisibilité.
	highlight clear SpellBad
	highlight SpellBad term=standout ctermfg=1 term=underline cterm=underline
	highlight clear SpellCap
	highlight SpellCap term=underline cterm=underline
	highlight clear SpellRare
	highlight SpellRare term=underline cterm=underline
	highlight clear SpellLocal
	highlight SpellLocal term=underline cterm=underline
endfunction

function! ToggleColorscheme()
	if ! exists( "g:colors_name" )
		let g:colors_name=g:dark_colors_name
	endif

	if g:colors_name == g:dark_colors_name
		execute "colorscheme ".g:light_colors_name
	else
		execute "colorscheme ".g:dark_colors_name
	endif

	if !has("gui")
		call SpellSettings()
	endif
endfunction

if g:first_load == 1
	if exists( "g:colors_name" )
		execute "colorscheme ".g:colors_name
		if !has("gui")
			call SpellSettings()
		endif
	endif
endif
map <silent> <F6> :call ToggleColorscheme()<CR>

"	============================================================================
"	UndoTree
"	============================================================================
if has("persistent_undo")
    set undodir=~/.vim/undodir/
    set undofile
endif
let g:undotree_WindowLayout=3
nnoremap <silent> <F7> :UndotreeToggle<CR>

"	============================================================================
"	clean_log
"	============================================================================
function! Clean_log()
	if expand('%:t:r')
		call system('clean_log ' . shellescape(bufname("%")))
		echo "log cleaned"
	else
		echo bufname("%") . " not a log file."
	endif
endfunction
autocmd Filetype log :call Clean_log<CR>
nnoremap <silent> <F8> :call Clean_log()<CR>

"	============================================================================
"	Tips
"	============================================================================
function! ToggleVimTips()
	if ! exists( "g:vimtips" )
		let g:vimtips='off'
	endif

	if g:vimtips == "on"
		let g:vimtips="off"
		pclose
	else
		let g:vimtips="on"
		set previewheight=5
		pedit! ~/.vimtips
	endif
endfunction
nnoremap <silent> <F9> :call ToggleVimTips()<CR>

"	============================================================================
"	Recharger .vimrc
"	============================================================================
map <F10> :so $MYVIMRC<CR>

"	============================================================================
"	Permet de ce déplacer d'une modification à l'autre.
"	============================================================================
nnoremap <silent> <C-p> :GitGutterPrevHunk<CR>
nnoremap <silent> <C-n> :GitGutterNextHunk<CR>

"	============================================================================

endif "!has("compatible")

