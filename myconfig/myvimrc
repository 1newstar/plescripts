if !exists( "g:first_load" )
	" Permet d'éviter certaines actions sur
	" un rechargement du fichier
	let g:first_load=1
else
	let g:first_load=0
endif

"	Pathogen
let g:pathogen_disabled = []
if has("gui_running")
	call add(g:pathogen_disabled, 'vim-togglemouse')
endif

call pathogen#infect()
call pathogen#helptags()

" Restore screen size and position
" Saves data in a separate file, and so works with multiple instances of Vim.
if has("gui_running")
  function! ScreenFilename()
    if has('amiga')
      return "s:.vimsize"
    elseif has('win32')
      return $HOME.'\_vimsize'
    else
      return $HOME.'/.vimsize'
    endif
  endfunction

  function! ScreenRestore()
    " - Remembers and restores winposition, columns and lines stored in
    "   a .vimsize file
    " - Must follow font settings so that columns and lines are accurate
    "   based on font size.
    if !has("gui_running")
      return
    endif
    if g:screen_size_restore_pos != 1
      return
    endif
    let vim_instance = (g:screen_size_by_vim_instance==1?(v:servername):'GVIM')
    " read any existing variables from .vimsize file
    silent! execute "sview " . escape(ScreenFilename(),'%#\ $')
    silent! execute "0/^" . vim_instance . " /"
    let vim_name  = matchstr(getline('.'), '^\w\+')
    let vim_cols  = matchstr(getline('.'), '^\w\+\s\+\zs\d\+')
    let vim_lines = matchstr(getline('.'), '^\w\+\s\+\d\+\s\+\zs\d\+')
    let vim_posx  = matchstr(getline('.'), '^\w\+\s\+\d\+\s\+\d\+\s\+\zs\d\+')
    let vim_posy  = matchstr(getline('.'), '^\w\+\s\+\d\+\s\+\d\+\s\+\d\+\s\+\zs\d\+')
    if vim_name == vim_instance
      execute "set columns=".vim_cols
      execute "set lines=".vim_lines
      silent! execute "winpos ".vim_posx." ".vim_posy
    endif
    silent! q
  endfunction

  function! ScreenSave()
    " used on exit to retain window position and size
    if !has("gui_running")
      return
    endif
    if !g:screen_size_restore_pos
      return
    endif
    let vim_instance = (g:screen_size_by_vim_instance==1?(v:servername):'GVIM')
    silent! execute "split " . escape(ScreenFilename(),'%#\ $')
    silent! execute "0/^" . vim_instance . " /"
    let vim_name  = matchstr(getline('.'), '^\w\+')
    if vim_name == vim_instance
      delete _
    endif
    $put = vim_instance . ' ' . &columns . ' ' . &lines . ' ' .
          \ (getwinposx()<0?0:getwinposx()) . ' ' .
          \ (getwinposy()<0?0:getwinposy())
    silent! x!
  endfunction

  if !exists('g:screen_size_restore_pos')
    let g:screen_size_restore_pos = 1
  endif
  if !exists('g:screen_size_by_vim_instance')
    let g:screen_size_by_vim_instance = 1
  endif
  autocmd VimEnter * call ScreenRestore()
  autocmd VimLeavePre * call ScreenSave()
endif

" Pour mes fichiers template je désactive la syntaxe
autocmd BufNewFile,BufRead *.template set syn=off

"	Activé pour le plugin markdown
filetype plugin on

set ts=4
set sw=4
if has("gui_running")
	let g:colors_name1 = 'github'
	let g:colors_name2 = 'sourcerer'
	set guifont=Monospace\ 12
	set guioptions+=b
	set cc=81 nowrap
else
	silent! set mouse=a
	let g:colors_name1 = 'github'
	let g:colors_name2 = 'sourcerer'
	set cc=81 nu wrap linebreak
endif

set listchars=tab:→\ ,eol:¬,trail:⋅,nbsp:⋅

"	Recharge automatiquement les fichiers modifiés.
set autoread

"   Ne charge pas le driver noshowmatch qui est trop lent.
let loaded_matchparen = 1

"Pour que airline soit visible tout le temps
set laststatus=2

"Search
set hlsearch
set incsearch

" Don't redraw while executing macros (good performance config)
set lazyredraw

" For regular expressions turn magic on
set magic

"	============================================================================
"	Syntastic : configuration conseillé
"	============================================================================
set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*
" Ne fonctionne pas avec Airline :(
"set statusline+=%{&spelllang}

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0

"	============================================================================
"	Dictionnaire :
"	============================================================================
"let g:languagetool_jar=$HOME.'/LanguageTool-2.9/languagetool.jar'
function! TristateNodictFrUs()
	if (! exists ("g:active_lang"))
		let g:active_lang = 'no'
	endif

	if g:active_lang == 'no'
		:echo "Dictionnaire français."
		let g:active_lang='fr'
		:set spell spelllang=fr
		if exists( "g:languagetool_jar" )
			:LanguageToolCheck
		endif
	elseif g:active_lang == 'fr'
		:echo "Dictionnaire US."
		let g:active_lang='us'
		:set spelllang=en_us
		if exists( "g:languagetool_jar" )
			:LanguageToolCheck
		endif
	elseif g:active_lang == 'us'
		:echo "Dictionnaire désactivé."
		let g:active_lang='no'
		:set nospell
		if exists( "g:languagetool_jar" )
			:LanguageToolClear
		endif
	endif
endfunction
map <F2> :call TristateNodictFrUs()<CR>

"	============================================================================
"	Foldmethod
"	============================================================================
set foldlevel=0
set foldnestmax=1

"	Permet de (un)folder la fonction courante avec la touche space.
nnoremap <silent> <Space> @=(foldlevel('.')?'za':"\<Space>")<CR>
vnoremap <Space> zf

function! ToggleAllFolders()
	if (! exists ("b:toggle_all_folders_state"))
		let b:toggle_all_folders_state = 'folded'
	endif

	if b:toggle_all_folders_state == 'folded'
		:echo "Functions unfolded"
		let b:toggle_all_folders_state='unfolded'
		normal! zR
	else
		:echo "Functions folded"
		let b:toggle_all_folders_state='folded'
		normal! zM
	endif
endfunction
map <F3> :call ToggleAllFolders()<CR>

function! CallbackShellFoldBrace()
	if getline(v:lnum+1)[0] == '{'
		return '>1'
	endif

	if getline(v:lnum)[0] == '}'
		return '<1'
	endif

	return -1
endfunction
set foldexpr=CallbackShellFoldBrace()

function! EnableShellFoldBrace()
	if &filetype == '' && getline(1) == '#!.*sh'
		set filetype=sh
	endif

	if &filetype == 'sh'
		set foldmethod=expr
	else
		set foldmethod=manual
		if exists ("g:toggle_all_folders_state") && g:toggle_all_folders_state == 'folded'
			call ToggleAllFolders()
		endif
	endif
endfunction
autocmd BufNewFile,BufRead * call EnableShellFoldBrace()

"	============================================================================
"	Répertoires :
"	Bascule entre $HOME et $HOME/plescripts
"	============================================================================
"	NERDTreeChDirMode
function! ToggleHOME2Plescripts ()
	let l:new_dir=$HOME
	if getcwd() == $HOME
		let l:new_dir='$HOME/plescripts'
	endif
	execute "cd ".l:new_dir
	execute "NERDTree ".l:new_dir
	wincmd p	"Go to previous windows
endfunction
map <silent> <F4> :call ToggleHOME2Plescripts()<CR>

"	============================================================================
"	NERDTree
"	============================================================================
let NERDTreeIgnore=['\.swp$', '\~$']

if has( "gui_running" )
	" NERDTree ouvert automatiquement
	autocmd VimEnter * NERDTree %:p:h
else
	" NERDTree ouvert si aucun fichier n'est passé en paramètre.
	autocmd StdinReadPre * let s:std_in=1
	autocmd VimEnter * if argc() == 0 && !exists("s:std_in") | NERDTree %:p:h | endif
endif
map <silent> <F5> :NERDTreeToggle<CR>

"Si NERDTree est la dernière fenêtre ouverte alors quitter [G]vim
autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif

" Go to previous (last accessed) window.
autocmd VimEnter * wincmd p

"	============================================================================
"	Thème :
"	============================================================================
function! ToggleColorscheme()
	if ! exists( "g:colors_name" )
		let g:colors_name=g:colors_name2
	endif

	if g:colors_name == g:colors_name2
		execute "colorscheme ".g:colors_name1
	else
		execute "colorscheme ".g:colors_name2
	endif
endfunction

if g:first_load == 1
	" Évite de changer de thème sur un reload
	:call ToggleColorscheme()
endif
map <silent> <F6> :call ToggleColorscheme()<CR>

"	============================================================================
"	Recharger .vimrc
"	============================================================================
map <F10> :so $MYVIMRC<CR>

"	============================================================================
"	Tips
"	============================================================================
function! ToggleVimTips()
	if ! exists( "g:vimtips" )
		let g:vimtips='off'
	endif

	if g:vimtips == "on"
		let g:vimtips="off"
		pclose
	else
		let g:vimtips="on"
		set previewheight=5
		pedit! ~/.vimtips
	endif
endfunction

" En test
if has("persistent_undo")
    set undodir=~/.vim/undodir/
    set undofile
endif
let g:undotree_WindowLayout=3
nnoremap <silent> <F7> :UndotreeToggle<CR>

nnoremap <silent> <F9> :call ToggleVimTips()<CR>

"	Permet de ce déplacer d'une modification à l'autre.
nnoremap <silent> <C-p> :GitGutterPrevHunk<CR>
nnoremap <silent> <C-n> :GitGutterNextHunk<CR>

function! ReadmeSwap()
	if expand('%:t') == 'readme.txt'
		let l:source=expand('%:p')
		let l:dest=expand('%:p:h').'/README.md'
	elseif expand('%:t') == 'README.md'
		let l:source=expand('%:p')
		let l:dest=expand('%:p:h').'/readme.txt'
	endif

	if exists( "l:source" )
		execute "silent !cp ".l:source." ".l:dest
		let l:msg="cp ".l:source." ".l:dest
		echomsg l:msg
		"execute ":echom '".l:msg."'"
	else
		echo "Seulement avec readme.txt/README.md"
	endif
endfunction
nnoremap <silent> <F8> :call ReadmeSwap()<CR>

"	============================================================================
