set ts=4
set sw=4
set listchars=tab:→\ ,eol:¬,trail:⋅,nbsp:⋅
"set cc=81 wrap
set nu
set vb t_vb=
set noerrorbells

if !has("compatible")
"	A partir d'ici la configuration n'est pas compatible avec vi.

if !exists( "g:first_load" )
	" Permet d'éviter certaines actions sur
	" un rechargement du fichier
	let g:first_load=1
else
	let g:first_load=0
endif

if g:first_load == 1
	if has("gui_running")
		set nonu
	else
		set nu
	endif
	set cc=0
endif

set modeline

"	Pathogen
let g:pathogen_disabled = []
if has("gui_running")
	call add(g:pathogen_disabled, 'vim-togglemouse')
endif

call pathogen#infect()
call pathogen#helptags()

if has("gui_running")
	set columns=120
	set lines=48
	winpos 0 36
endif

" Pour mes fichiers template je désactive la syntaxe
autocmd BufRead *.template,*.doc.sh set syn=off

"	Activé pour le plugin markdown
filetype plugin on

" Change the mapleader from \ to ,
let mapleader=","
let maplocalleader="\\"

if has("gui_running")
	let g:light_colors_name = 'github'
	let g:dark_colors_name = 'sourcerer'
	let g:colors_name=g:light_colors_name	" Théme par défaut
	set guifont=Monospace\ 12
	set guioptions+=b
	"set cc=81 nonu nowrap
else
	silent! set mouse=a
	let g:light_colors_name = 'github'
	let g:dark_colors_name = 'sourcerer'
	"	Théme par défaut
	if $HOSTNAME == 'K2'
		let g:colors_name=g:dark_colors_name
	else
		let g:colors_name=g:light_colors_name
	endif

	"set cc=81 nu wrap linebreak
endif

"	Recharge automatiquement les fichiers modifiés.
set autoread

"   Ne charge pas le driver noshowmatch qui est trop lent.
let loaded_matchparen = 1

"Pour que airline soit visible tout le temps
set laststatus=2

"Search
set hlsearch
set incsearch

" Don't redraw while executing macros (good performance config)
set lazyredraw

" For regular expressions turn magic on
set magic

"	============================================================================
"	Syntastic : configuration conseillé
"	============================================================================
set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*
" Ne fonctionne pas avec Airline :(
set statusline+=%{&spelllang}

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 1

autocmd BufRead *.template,*.doc.sh let g:syntastic_check_on_open = 0

"	============================================================================
function! CheckFileType()
	if &filetype == '' && getline(1) == '#!.*sh'
		set filetype=sh
	endif

	if &filetype == 'sh' || &filetype == 'c' || &filetype == 'cpp' || &filetype == 'cfg' || &filetype == 'markdown'
		if has("gui_running" )
			set cc=81 nonu nowrap
		else
			set cc=81 nu wrap linebreak
		endif
	elseif &filetype == 'man'
		set cc=0 nonu
	else
		set cc=0 nu
	endif
endfunction
autocmd! BufRead * call CheckFileType()

"	============================================================================
"	Dictionnaire :
"	============================================================================
let g:grammarous#disabled_rules = {
	\ '*' : ['FRENCH_WHITESPACE,WHITESPACE_RULE,FIXTURE,EMAIL,HUNSPELL_NO_SUGGEST_RULE'],
	\ 'help' : ['WHITESPACE_RULE', 'EN_QUOTES', 'SENTENCE_WHITESPACE', 'UPPERCASE_SENTENCE_START'],
	\ }
function! FrGrammaire()
	if (! exists ("b:grammar_is"))
		let b:grammar_is = 'no'
	endif

	if b:grammar_is == 'us'
		let b:grammar_is='no'
		:LanguageToolClear
	endif

	if b:grammar_is == 'no'
		:echo "Grammaire française activée."
		let b:grammar_is='fr'
		if ( &filetype == 'sh' )
			:GrammarousCheck --lang=fr --comments-only
		else
			:GrammarousCheck --lang=fr --no-comments-only
		endif
	elseif b:grammar_is == 'fr'
		:echo "Grammaire française désactivée."
		let b:grammar_is='no'
		:GrammarousReset
	endif
endfunction

function! FrDictionnaire()
	if (! exists ("b:dictionnary_is"))
		let b:dictionnary_is = 'no'
	endif

	if b:dictionnary_is == 'us'
		let b:dictionnary_is='no'
		:setlocal nospell
	endif

	if b:dictionnary_is == 'no'
		:echo "Dictionnaire français."
		let b:dictionnary_is='fr'
		:setlocal spell spelllang=fr
	elseif b:dictionnary_is == 'fr'
		:echo "Dictionnaire désactivé."
		let b:dictionnary_is='no'
		:setlocal nospell
	endif
endfunction

function! UsGrammaire()
	if (! exists ("b:grammar_is"))
		let b:grammar_is = 'no'
	endif

	if b:grammar_is == 'fr'
		let b:grammar_is='no'
		:setlocal nospell
		if exists( "g:languagetool_jar" )
			:LanguageToolClear
		endif
	endif

	if b:grammar_is == 'no'
		:echo "Dictionnaire US."
		let b:grammar_is='us'
		:setlocal spell spelllang=en_us
		if exists( "g:languagetool_jar" )
			:LanguageToolCheck
		endif
	elseif b:grammar_is == 'us'
		:echo "Dictionnaire désactivé."
		let b:grammar_is='no'
		:setlocal nospell
		if exists( "g:languagetool_jar" )
			:LanguageToolClear
		endif
	endif
endfunction

nnoremap <F2> :call FrDictionnaire()<CR>
"if exists( "g:languagetool_jar" )
	nnoremap <C-g> :call FrGrammaire()<CR>
"endif

"	============================================================================
"	Foldmethod
"	============================================================================
set foldlevel=0
set foldnestmax=1

"	Permet de (un)folder la fonction courante avec la touche space.
nnoremap <silent> <Space> @=(foldlevel('.')?'za':"\<Space>")<CR>
vnoremap <Space> zf

function! ToggleAllFolders()
	if (! exists ("b:toggle_all_folders_state"))
		let b:toggle_all_folders_state = 'folded'
	endif

	if b:toggle_all_folders_state == 'folded'
		:echo "Functions unfolded"
		let b:toggle_all_folders_state='unfolded'
		normal! zR
	else
		:echo "Functions folded"
		let b:toggle_all_folders_state='folded'
		normal! zM
	endif
endfunction
map <F3> :call ToggleAllFolders()<CR>

function! CallbackShellFoldBrace()
	if getline(v:lnum+1)[0] == '{'
		return '>1'
	endif

	if getline(v:lnum)[0] == '}'
		return '<1'
	endif

	return -1
endfunction
set foldexpr=CallbackShellFoldBrace()

function! EnableShellFoldBrace()
	if &filetype == 'sh'
		set foldmethod=expr
	else
		set foldmethod=manual
		if exists ("g:toggle_all_folders_state") && g:toggle_all_folders_state == 'folded'
			call ToggleAllFolders()
		endif
	endif
endfunction
autocmd BufRead * call EnableShellFoldBrace()

"	============================================================================
"	Répertoires :
"	Bascule entre $HOME et $HOME/plescripts
"	============================================================================
"	NERDTreeChDirMode
function! ToggleHOME2Plescripts ()
	let l:new_dir=$HOME
	if getcwd() == $HOME
		let l:new_dir='$HOME/plescripts'
	endif
	execute "cd ".l:new_dir
	execute "NERDTree ".l:new_dir
	wincmd p	"Go to previous windows
endfunction
map <silent> <F4> :call ToggleHOME2Plescripts()<CR>

"	NERDTreeChDirMode
function! ToggleHOME2Plewiki ()
	let l:new_dir=$HOME
	if getcwd() == $HOME
		let l:new_dir='$HOME/plewiki'
	endif
	execute "cd ".l:new_dir
	execute "NERDTree ".l:new_dir
	wincmd p	"Go to previous windows
endfunction
"map <silent> <C-F4> :call ToggleHOME2Plewiki()<CR>


"	============================================================================
"	NERDTree
"	============================================================================
let NERDTreeIgnore=['\.swp$', '\~$']

if has( "gui_running" )
	" NERDTree ouvert automatiquement
	autocmd VimEnter * NERDTree %:p:h
else
	" NERDTree ouvert si aucun fichier n'est passé en paramètre.
	autocmd StdinReadPre * let s:std_in=1
	autocmd VimEnter * if argc() == 0 && !exists("s:std_in") | NERDTree %:p:h | endif
endif
map <silent> <F5> :NERDTreeToggle<CR>

"Si NERDTree est la dernière fenêtre ouverte alors quitter [G]vim
autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif
" Go to previous (last accessed) window.
autocmd VimEnter * wincmd p

"	============================================================================
"	Thème :
"	============================================================================
function! SpellSettings()
	" Améliore considérablement la lisibilité.
	highlight clear SpellBad
	highlight SpellBad term=standout ctermfg=1 term=underline cterm=underline
	highlight clear SpellCap
	highlight SpellCap term=underline cterm=underline
	highlight clear SpellRare
	highlight SpellRare term=underline cterm=underline
	highlight clear SpellLocal
	highlight SpellLocal term=underline cterm=underline
endfunction

function! ToggleColorscheme()
	if ! exists( "g:colors_name" )
		let g:colors_name=g:dark_colors_name
	endif

	if g:colors_name == g:dark_colors_name
		execute "colorscheme ".g:light_colors_name
	else
		execute "colorscheme ".g:dark_colors_name
	endif

	if !has("gui")
		call SpellSettings()
	endif
endfunction

if g:first_load == 1
	if exists( "g:colors_name" )
		execute "colorscheme ".g:colors_name
		if !has("gui")
			call SpellSettings()
		endif
	endif
endif
map <silent> <F6> :call ToggleColorscheme()<CR>

"	============================================================================
"	UndoTree
"	============================================================================
if has("persistent_undo")
    set undodir=~/.vim/undodir/
    set undofile
endif
let g:undotree_WindowLayout=3
nnoremap <silent> <F7> :UndotreeToggle<CR>

"	============================================================================
"	clean_log
"	============================================================================
function! Clean_log()
	if expand('%:t:r')
		call system('clean_log ' . shellescape(bufname("%")))
		execute ":e%"
	endif
endfunction
"autocmd Filetype log  :call Clean_log<CR>
autocmd BufRead * call Clean_log()
nnoremap <silent> <F8> :call Clean_log()<CR>

"	============================================================================
"	Tips
"	============================================================================
function! ToggleVimTips()
	if ! exists( "g:vimtips" )
		let g:vimtips='off'
	endif

	if g:vimtips == "on"
		let g:vimtips="off"
		pclose
	else
		let g:vimtips="on"
		set previewheight=5
		pedit! ~/.vimtips
	endif
endfunction
nnoremap <silent> <F9> :call ToggleVimTips()<CR>

"	============================================================================
"	Recharger .vimrc
"	============================================================================
map <F10> :so $MYVIMRC<CR>

"	============================================================================
"	Permet de ce déplacer d'une modification à l'autre.
"	============================================================================
nnoremap <silent> <C-p> :GitGutterPrevHunk<CR>
nnoremap <silent> <C-n> :GitGutterNextHunk<CR>

"	============================================================================
"	Fait un man du mot sous le curseur.
"	============================================================================
function! ManWordUnderTheCursor()
	let l:wordUnderCursor = expand("<cword>")
	":Man . " &l:wordUnderCursor"
	":Man printf
	execute "Man " . &l:wordUnderCursor
endfunction
nnoremap <silent> <C-M> :call ManWordUnderTheCursor()<CR>

"	============================================================================

endif "!has("compatible")

